#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Script that plots comparisons of the model forms.

This file is part of the TractLSM model.

Copyright (c) 2022 Manon E. B. Sabot

Please refer to the terms of the MIT License, which you should have
received along with the TractLSM.

"""

__title__ = "Impact of different model forms"
__author__ = "Manon E. B. Sabot"
__version__ = "1.0 (28.05.2021)"
__email__ = "m.e.b.sabot@gmail.com"


# ======================================================================

# general modules
import os  # check for paths
import sys  # check for files, versions
import numpy as np  # array manipulations, math operators
import pandas as pd  # read/write dataframes, csv files
import warnings  # ignore warnings

# plotting modules
import matplotlib as mpl  # general matplotlib libraries
import matplotlib.pyplot as plt  # plotting interface
import string   # automate subplot lettering

# own modules
from plot_utils import default_plt_setup
from plot_utils import model_order, which_model
from plot_utils import render_xlabels, render_ylabels

# change the system path to load modules from TractLSM
script_dir = os.path.dirname(os.path.realpath(sys.argv[0]))
sys.path.append(os.path.abspath(os.path.join(script_dir, '..')))

from TractLSM.Utils import get_main_dir  # get the project's directory
from TractLSM.Utils import read_csv  # read in files
from calibrations.calib_utils import soil_water  # soil moist. profiles
from TractLSM import hrun  # run the models

# ignore these warnings
warnings.filterwarnings("ignore", category=FutureWarning)
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)


# ======================================================================

def main(swater, week, models):

    """
    Main function: plots model outputs as generated by differing model
                   forms

    Arguments:
    ----------
    swater: string
        the soil moisture profile to consider

    week: int
        out of the four weeks of idealised forcing, which one to plot?

    models: list
        the models to plot

    Returns:
    --------
    'deriv_vs_not.jpg' in output/plots

    """

    base_dir = get_main_dir()  # working paths

    # figure
    fname = os.path.join(os.path.join(os.path.join(base_dir, 'output'),
                         'plots'), 'deriv_vs_not.jpg')

    if not os.path.isfile(fname):
        default_plt_setup()  # default figure specs

        # colours to consider, based on the models called
        ref_models = [which_model(e).split('-')[0].split('$')[0] for e
                      in model_order()]
        ref_colours = plt.rcParams['axes.prop_cycle'].by_key()['color']
        colours = [ref_colours[ref_models.index(e)] for e in models]

        default_plt_setup(colours=colours)  # actual figure specs

        # input data for which to generate the output
        df, __ = read_csv(os.path.join(os.path.join(os.path.join(
                          os.path.join(base_dir, 'input'), 'simulations'),
                          'idealised'), '%s_calibrated.csv' % (swater)))

        # get the associated output
        alow, dlow, ahigh, dhigh = contrast_model_versions(df, week)

        # now plot them for comparison
        plot_comparison(alow, dlow, ahigh, dhigh, fname)

    return


def contrast_model_versions(df, week):

    """
    Generates model outputs from different model versions / forms

    Arguments:
    ----------
    df: pandas dataframe
        dataframe containing all input data & params

    week: int
        out of the four weeks of idealised forcing, which one to run?

    Returns:
    --------
    df1: pandas dataframe
        dataframe containing output data from the actual model forms ran
        at low resolution

    df2: pandas dataframe
        dataframe containing output data from the derivative model forms
        ran at low resolution

    df3: pandas dataframe
        dataframe containing output data from the actual model forms ran
        at high resolution

    df4: pandas dataframe
        dataframe containing output data from the derivative model forms
        ran at high resolution

    """

    # add the soil moisture profile
    df['sw'] = df['theta_sat']
    df.fillna(method='ffill', inplace=True)
    df['sw'], df['Ps'] = soil_water(df, 'wet')

    # select the week of data
    df = df[np.logical_and(df['doy'] >= df['doy'].min() + 7 * (week - 1),
                           df['doy'] <= df['doy'].min() + 7 * week)].copy()

    # actual model form, low resolution
    df1 = hrun(None, df, 48, 'Farquhar', models=models,
               resolution='low', inf_gb=True)
    df1.columns = df1.columns.droplevel(level=1)

    # derivative model form, low resolution
    df2 = hrun(None, df, 48, 'Farquhar', models=models,
               resolution='low', inf_gb=True, deriv=True)
    df2.columns = df2.columns.droplevel(level=1)

    # actual model form, high resolution
    df3 = hrun(None, df, 48, 'Farquhar', models=models,
               resolution='high', inf_gb=True)
    df3.columns = df3.columns.droplevel(level=1)

    # derivative model form, high resolution
    df4 = hrun(None, df, 48, 'Farquhar', models=models,
               resolution='high', inf_gb=True, deriv=True)
    df4.columns = df4.columns.droplevel(level=1)

    return df1, df2, df3, df4


def plot_comparison(df1, df2, df3, df4, figname):

    """
    Generates comparison plots for the model outputs from different
    model versions / forms

    Arguments:
    ----------
    df1: pandas dataframe
        dataframe containing output data from the actual model forms ran
        at low resolution

    df2: pandas dataframe
        dataframe containing output data from the derivative model forms
        ran at low resolution

    df3: pandas dataframe
        dataframe containing output data from the actual model forms ran
        at high resolution

    df4: pandas dataframe
        dataframe containing output data from the derivative model forms
        ran at high resolution

    figname: string
        name of the figure to produce, including path

    Returns:
    --------
    'deriv_vs_not.jpg'

    """

    # declare figure
    fig, axes = plt.subplots(figsize=(4., 4), nrows=2, ncols=2, sharex=True,
                             sharey='row')
    plt.subplots_adjust(hspace=0.1, wspace=0.1)
    axes = axes.flat  # flatten axes

    for i, df in enumerate([df1, df2, df3, df4]):

        if i % 2 == 0:
            ls = '-'

        else:
            ls = ':'

        ax1 = axes[0]
        ax2 = axes[2]

        if i > 1:
            ax1 = axes[1]
            ax2 = axes[3]

        for j, mod in enumerate(['wue', 'pmax', 'cgn', 'pmax2', 'lcst']):

            if i < 1:
                ax1.plot(df['hod'], df['gs(%s)' % (mod)], ls=ls,
                         label=which_model(mod))

            else:
                ax1.plot(df['hod'], df['gs(%s)' % (mod)], ls=ls)

            ax2.plot(df['hod'], df['Pleaf(%s)' % (mod)], ls=ls)

    bottom, __ = axes[0].get_ylim()
    axes[0].set_ylim(bottom, 0.25)

    iter = 0

    for ax in [axes[0], axes[1], axes[2], axes[3]]:  # format axes ticks

        ax.xaxis.set_major_locator(mpl.ticker.MaxNLocator(3))
        ax.yaxis.set_major_locator(mpl.ticker.MaxNLocator(4))

        if (ax == axes[-1]) or (ax == axes[-2]):
            ax.xaxis.set_major_formatter(mpl.ticker.FormatStrFormatter('%d'))
            ax.yaxis.set_major_locator(mpl.ticker.MaxNLocator(3))

        else:
            ax.set_xticklabels([])

        if (ax == axes[0]) or (ax == axes[1]):  # gs and Ci:Ca
            ax.yaxis.set_major_formatter(mpl.ticker.FormatStrFormatter('%.2f'))

        else:
            ax.yaxis.set_major_formatter(mpl.ticker.FormatStrFormatter('%.1f'))

        # subplot labelling
        t = ax.text(0.875, 0.925,
                    r'\textbf{(%s)}' % (string.ascii_lowercase[iter]),
                    transform=ax.transAxes, weight='bold')
        t.set_bbox(dict(boxstyle='round,pad=0.1', fc='w', ec='none',
                   alpha=0.8))
        iter += 1

    # axes labels
    render_xlabels(axes[-1], 'hour of day', 'h')
    render_xlabels(axes[-2], 'hour of day', 'h')
    render_ylabels(axes[0], r'$g_{s}$', r'mol m$^{-2}$ s$^{-1}$')
    render_ylabels(axes[-2], r'$\Psi$$_{l}$', 'MPa')

    # axes suptitles
    axes[0].set_title('Low resolution')
    axes[1].set_title('High resolution')

    # split the legend in several parts
    axes[0].legend(loc=2, bbox_to_anchor=(2.15, 0.225), handleheight=1.5,
                   labelspacing=0.1)
    fig.savefig(figname)
    plt.close()

    return


###############################################################################

if __name__ == "__main__":

    # user input
    swater = 'wet'
    week = 4
    models = ['WUE', 'ProfitMax', 'CGain', 'ProfitMax2', 'LeastCost']

    main(swater, week, models)
